#### gc

+ 判断对象是否存活
  * 引用计数算法
  * 根搜索算法(GC Root/gcroot)
    - 1 . 虚拟机栈（栈帧中的本地变量表）中的引用的对象。
      * 我们在程序中正常创建一个对象，对象会在堆上开辟一块空间，同时会将这块空间的地址作为引用保存到虚拟机栈中，如果对象生命周期结束了，那么引用就会从虚拟机栈中出栈，因此如果在虚拟机栈中有引用，就说明这个对象还是有用的，这种情况是最常见的。
    - 2 . 方法区中的类静态属性引用的对象。
      - static关键字
    - 3 . 方法区中的常量引用的对象。
      - 使用了static final关键字
    - 4 . 本地方法栈中JNI（即一般说的Native方法）的引用的对象。
      - Java中调用C或C++的代码，因此会使用native方法，JVM内存中专门有一块本地方法栈，用来保存这些对象的引用
+ 标记-清除：由标记阶段和清除阶段构成。在标记阶段会把所有的活动对象都做上标记，然后在清除阶段会把没有标记的对象，也就是非活动对象回收。
  * 标记阶段就是遍历对象并标记的处理过程
  * 清除阶段，collector 会遍历整个堆，回收没有打上标记的对象
  * 当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将**程序暂停**，随后将依旧存活的对象标记一遍，最终再将堆中所有没被标记的对象全部清除掉，接下来便让**程序恢复运行**。
  * 缺点
    - 清理出来的空闲内存是不连续的
    - 效率比较低（递归与全堆对象遍历）
    - 停止应用程序
  
  
+ 复制： 复制算法将内存划分为两个区间，在任意时间点，所有动态分配的对象都只能分配在其中一个区间（称为活动区间），而另外一个区间（称为空闲区间）则是空闲的。
  * 当有效内存空间耗尽时，JVM将暂停程序运行，开启复制算法GC线程。接下来GC线程会将活动区间内的存活对象，全部复制到空闲区间，且严格按照内存地址依次排列，与此同时，GC线程将更新存活对象的内存引用地址指向新的内存地址。
  缺点
    - 它浪费了一半的内存
    - 复制所花费的时间，在对象存活率达到一定程度时，将会变的不可忽视
    - 复制算法要想使用，最起码对象的存活率要非常低

+ 标记-整理
  * 标记阶段同标记清除
  * 整理：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收
  * 缺点
    - 唯一的缺点就是效率也不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。从效率上来说，标记/整理算法要低于复制算法  
    
##### 总结
1. 三个算法都基于根搜索算法去判断一个对象是否应该被回收，而支撑根搜索算法可以正常工作的理论依据，就是语法中变量作用域的相关内容。因此，要想防止内存泄露，最根本的办法就是掌握好变量作用域
2. 在GC线程开启时，或者说GC过程开始时，它们都要暂停应用程序（stop the world）